#include "RenderTexture.h"
#include "Camera.h"
#include "RenderBase.h"
#include "RenderWindow.h"
#include <memory>
using namespace std;

RenderTexture::RenderTexture() :
	pos(0), scale(1), rot(0), size(0),
	anchorPoint(0.5f), color(Color::white),
	vertexBuffer(new VertexBuffer<VertexPosUv>),
	constantBufferTransform(new ConstantBuffer<ConstantBufferDataTransform2D>),
	constantBufferColor(new ConstantBuffer<ConstantBufferDataColor>)
{
}

RenderTexture::~RenderTexture()
{
	delete vertexBuffer;
	delete constantBufferTransform;
	delete constantBufferColor;
}

void RenderTexture::Initialize()
{
	HRESULT result;

	RenderBase* renderBase = RenderBase::GetInstance();
	RenderWindow* renderWindow = RenderWindow::GetInstance().get();

	CD3DX12_HEAP_PROPERTIES textureHeapProp =
		CD3DX12_HEAP_PROPERTIES(
			D3D12_CPU_PAGE_PROPERTY_WRITE_BACK,
			D3D12_MEMORY_POOL_L0);

	CD3DX12_RESOURCE_DESC textureResourceDesc =
		CD3DX12_RESOURCE_DESC::Tex2D(
			DXGI_FORMAT_R8G8B8A8_UNORM,
			renderWindow->GetWindowSize().x,
			renderWindow->GetWindowSize().y,
			1, 1, 1, 0, D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET);

	// テクスチャのサイズをセット
	texture.size = { (float)textureResourceDesc.Width, (float)textureResourceDesc.Height };

	// テクスチャバッファの生成
	result = RenderBase::GetInstance()->GetDevice()->
		CreateCommittedResource(
			&textureHeapProp,
			D3D12_HEAP_FLAG_NONE,
			&textureResourceDesc,
			D3D12_RESOURCE_STATE_GENERIC_READ,
			nullptr,
			IID_PPV_ARGS(&texture.buffer));
	assert(SUCCEEDED(result));

	// テクスチャーを赤クリア
	{
		const UINT pixelCount = renderWindow->GetWindowSize().x * renderWindow->GetWindowSize().y;
		const UINT rowPitch = sizeof(UINT) * renderWindow->GetWindowSize().x;
		const UINT depthPitch = rowPitch * renderWindow->GetWindowSize().y;
		UINT* img = new UINT[pixelCount];
		for (int i = 0; i < pixelCount; i++)
		{
			img[i] = 0xff0000ff;
		}
		result = texture.buffer->WriteToSubresource(
			0,
			nullptr,
			img,
			rowPitch,
			depthPitch);
		assert(SUCCEEDED(result));
		delete img;
	}
	RenderBase::GetInstance()->CreateSrv(texture, textureResourceDesc);

	vertices.resize(4);
	vertices[0].uv = { 0.0f,1.0f };
	vertices[1].uv = { 0.0f,0.0f };
	vertices[2].uv = { 1.0f,1.0f };
	vertices[3].uv = { 1.0f,0.0f };
	vertexBuffer->Create(vertices);

	// 定数バッファ
	constantBufferTransform->Init();
	constantBufferColor->Init();

	//HRESULT result;

	// 頂点データ
	//vertices.resize(4);
	//vertices[0] = { { -(size.x / 2), +(size.y / 2), 0.0f },{0.0f, 1.0f} };	//左下
	//vertices[1] = { { -(size.x / 2), -(size.y / 2), 0.0f },{0.0f, 0.0f} };	//左上
	//vertices[2] = { { +(size.x / 2), +(size.y / 2), 0.0f },{1.0f, 1.0f} };	//右下
	//vertices[3] = { { +(size.x / 2), -(size.y / 2), 0.0f },{1.0f, 0.0f} };	//右上
	//vertexBuffer->Create(vertices);

	//vertices.resize(4);
	//vertices[0].uv = { 0.0f,1.0f };
	//vertices[1].uv = { 0.0f,0.0f };
	//vertices[2].uv = { 1.0f,1.0f };
	//vertices[3].uv = { 1.0f,0.0f };
	//vertexBuffer->Create(vertices);

	////// 定数バッファ
	//constantBufferTransform->Init();
	//constantBufferColor->Init();


	//unique_ptr<Texture> tempTex = TextureBuffer::GetRenderTexture(
	//	{
	//		(float)renderWindow->GetWindowSize().x,
	//		(float)renderWindow->GetWindowSize().y,
	//	});
	////componentManager->GetComponent<Texture>()->SetTexture(*tempTex);

	//// RTV用デスクリプタヒープ設定
	//D3D12_DESCRIPTOR_HEAP_DESC rtvDescHeapDesc = {};
	//rtvDescHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_RTV;
	//rtvDescHeapDesc.NumDescriptors = 1;
	//// RTV用デスクリプタヒープを作成
	//result = renderBase->GetDevice()->
	//	CreateDescriptorHeap(
	//		&rtvDescHeapDesc,
	//		IID_PPV_ARGS(&descHeapRTV));
	//assert(SUCCEEDED(result));

	//// レンダーターゲットビューの設定
	//D3D12_RENDER_TARGET_VIEW_DESC rtvDesc{};
	//// シェーダーの計算結果をSRGBに変換して書き込む
	//rtvDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
	//rtvDesc.ViewDimension = D3D12_RTV_DIMENSION_TEXTURE2D;
	//// デスクリプタヒープにRTV作成
	//ID3D12Resource* a = componentManager->GetComponent<Texture>()->buffer.Get();
	//auto b = a->GetDesc();

	//renderBase->GetDevice()->CreateRenderTargetView(
	//	componentManager->GetComponent<Texture>()->buffer.Get(),
	//	&rtvDesc,
	//	descHeapRTV->GetCPUDescriptorHandleForHeapStart());

	//// 深度バッファリソースの設定
	//CD3DX12_RESOURCE_DESC depthRecDesc =
	//	CD3DX12_RESOURCE_DESC::Tex2D(
	//		DXGI_FORMAT_D32_FLOAT,
	//		(UINT64)renderWindow->GetWindowSize().x,
	//		(UINT)renderWindow->GetWindowSize().y,
	//		1, 0, 1, 0, D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL);
	//// 深度バッファの生成
	//CD3DX12_HEAP_PROPERTIES depthHeapProperties = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT);
	//CD3DX12_CLEAR_VALUE depthClearValue = CD3DX12_CLEAR_VALUE(DXGI_FORMAT_D32_FLOAT, 1.0f, 0);
	//result = renderBase->GetDevice()->CreateCommittedResource(
	//	&depthHeapProperties,
	//	D3D12_HEAP_FLAG_NONE,
	//	&depthRecDesc,
	//	D3D12_RESOURCE_STATE_DEPTH_WRITE,
	//	&depthClearValue,
	//	IID_PPV_ARGS(&depthBuff));
	//assert(SUCCEEDED(result));

	//// DSV用デスクリプタヒープを作成
	//D3D12_DESCRIPTOR_HEAP_DESC dsvHeapDesc{};
	//dsvHeapDesc.NumDescriptors = 1;
	//dsvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_DSV;
	//result = renderBase->GetDevice()->CreateDescriptorHeap(&dsvHeapDesc, IID_PPV_ARGS(&descHeapDSV));
	//assert(SUCCEEDED(result));

	//// デスクリプタヒープの作成
	//D3D12_DEPTH_STENCIL_VIEW_DESC dsvViewDesc = {};
	//dsvViewDesc.Format = DXGI_FORMAT_D32_FLOAT;	// 深度地フォーマット
	//dsvViewDesc.ViewDimension = D3D12_DSV_DIMENSION_TEXTURE2D;
	//renderBase->GetDevice()->CreateDepthStencilView
	//(
	//	depthBuff.Get(),
	//	&dsvViewDesc,
	//	descHeapDSV->GetCPUDescriptorHandleForHeapStart()
	//);
}
void RenderTexture::Update()
{
	transform.pos = pos;
	transform.scale = { scale.x,scale.y,1 };
	transform.rot = { 0,0,rot };
	transform.Update();

	// 定数バッファに転送
	constantBufferTransform->constantBufferMap->mat =
		transform.worldMat *
		Camera::current.GetOrthoGrphicProjectionMat();

	// 色転送
	constantBufferColor->constantBufferMap->color = color / 255;
	constantBufferColor->constantBufferMap->color.a = color.a / 255;

	// 頂点バッファーに頂点を転送
	TransferTexturePos();
}

void RenderTexture::PreDrawScene()
{
	//RenderBase* renderBase = RenderBase::GetInstance().get();
	//RenderWindow* renderWindow = RenderWindow::GetInstance().get();

	//CD3DX12_RESOURCE_BARRIER resourceBarrier;
	//resourceBarrier = CD3DX12_RESOURCE_BARRIER::Transition(
	//	componentManager->GetComponent<Texture>()->buffer.Get(),
	//	D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE,
	//	D3D12_RESOURCE_STATE_RENDER_TARGET);

	////リソースバリアを変更（シェーダーリソース -> 描画可能）
	//renderBase->GetCommandList()->ResourceBarrier(1, &resourceBarrier);

	//// レンダーターゲットビュー用ディスクリプタヒープのハンドルを取得
	//D3D12_CPU_DESCRIPTOR_HANDLE rtvH = descHeapRTV->GetCPUDescriptorHandleForHeapStart();
	//// 深度ステンシルビュー用ディスクリプタヒープのハンドルを取得
	//D3D12_CPU_DESCRIPTOR_HANDLE dsvH = descHeapDSV->GetCPUDescriptorHandleForHeapStart();
	//// レンダーターゲットをセット
	//renderBase->GetCommandList()->OMSetRenderTargets(1, &rtvH, false, &dsvH);

	//// ビューポートの設定
	//CD3DX12_VIEWPORT viewport = CD3DX12_VIEWPORT(
	//	0.0f, 0.0f,
	//	renderWindow->GetWindowSize().x,
	//	renderWindow->GetWindowSize().y);

	//renderBase->GetCommandList()->RSSetViewports(1, &viewport);
	//// シザリング矩形の設定
	//CD3DX12_RECT scissorRect = CD3DX12_RECT(
	//	0, 0,
	//	renderWindow->GetWindowSize().x,
	//	renderWindow->GetWindowSize().y);

	//renderBase->GetCommandList()->RSSetScissorRects(1, &scissorRect);

	//// 全画面クリア
	//renderBase->GetCommandList()->ClearRenderTargetView(rtvH, RenderBase::clearColor, 0, nullptr);
	//// 深度バッファのクリア
	//renderBase->GetCommandList()->ClearDepthStencilView(dsvH, D3D12_CLEAR_FLAG_DEPTH, 1.0f, 0, 0, nullptr);
}
void RenderTexture::PostDrawScene()
{
	//RenderBase* renderBase = RenderBase::GetInstance().get();

	//// リソースバリアを変更（描画可能 -> シェーダーリソース）
	//CD3DX12_RESOURCE_BARRIER resourceBarrier;
	//resourceBarrier = CD3DX12_RESOURCE_BARRIER::Transition(
	//	componentManager->GetComponent<Texture>()->buffer.Get(),
	//	D3D12_RESOURCE_STATE_RENDER_TARGET,
	//	D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE);

	//renderBase->GetCommandList()->ResourceBarrier(1, &resourceBarrier);
}
void RenderTexture::Draw()
{
	RenderBase* renderBase = RenderBase::GetInstance();// .get();

	renderBase->GetCommandList()->SetPipelineState(renderBase->GetSpritePipeline()->GetAlphaPipeline());
	renderBase->GetCommandList()->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);

	// VBVとIBVの設定コマンド
	renderBase->GetCommandList()->IASetVertexBuffers(0, 1, vertexBuffer->GetvbViewAddress());

	// マテリアルとトランスフォームのCBVの設定コマンド
	renderBase->GetCommandList()->SetGraphicsRootConstantBufferView(
		0, constantBufferTransform->constantBuffer->GetGPUVirtualAddress());
	renderBase->GetCommandList()->SetGraphicsRootConstantBufferView(
		1, constantBufferColor->constantBuffer->GetGPUVirtualAddress());

	// SRVヒープの設定コマンド
	auto temp = renderBase->GetSrvDescHeap();
	renderBase->GetCommandList()->SetDescriptorHeaps(1, &temp);
	// SRVヒープの先頭にあるSRVをルートパラメータ2番に設定
	renderBase->GetCommandList()->SetGraphicsRootDescriptorTable(
		renderBase->GetSpriteRootSignature()->GetRootDescriptorTableIndex(), texture.GetGpuHandle());

	renderBase->GetCommandList()->DrawInstanced((unsigned short)vertices.size(), 1, 0, 0);
}

void RenderTexture::SetCutPosAndSize(const Vec2& cutPos, const Vec2& cutSize)
{
	//float texLeft = cutPos.x / componentManager->GetComponent<Texture>()->GetTextureSize().x;
	//float texRight = (cutPos.x + cutSize.x) / componentManager->GetComponent<Texture>()->GetTextureSize().x;
	//float texUp = cutPos.y / componentManager->GetComponent<Texture>()->GetTextureSize().y;
	//float texDown = (cutPos.y + cutSize.y) / componentManager->GetComponent<Texture>()->GetTextureSize().y;

	//vertices[0].uv = { texLeft , texDown };	// 左下
	//vertices[1].uv = { texLeft ,   texUp };	// 左上
	//vertices[2].uv = { texRight ,texDown }; // 右下
	//vertices[3].uv = { texRight ,  texUp }; // 右上

	//vertexBuffer->TransferToBuffer(vertices);
}

void RenderTexture::TransferTexturePos()
{
	// 新しいのサイズ
	float width = texture.size.x;
	float height = texture.size.y;

	// 現在のサイズ
	float width2 = vertices[0].pos.x - vertices[2].pos.x;
	float height2 = vertices[1].pos.x - vertices[3].pos.x;

	if (width != fabsf(width2) || width != fabsf(height2))
	{
		vertices[0].pos = { (0.0f - anchorPoint.x) * width,(1.0f - anchorPoint.y) * height,0.0f }; //左下
		vertices[1].pos = { (0.0f - anchorPoint.x) * width,(0.0f - anchorPoint.y) * height,0.0f }; //左上
		vertices[2].pos = { (1.0f - anchorPoint.x) * width,(1.0f - anchorPoint.y) * height,0.0f }; //右下
		vertices[3].pos = { (1.0f - anchorPoint.x) * width,(0.0f - anchorPoint.y) * height,0.0f }; //右上

		vertexBuffer->TransferToBuffer(vertices);
	}
}